"""
AI Policy Generation Service
============================
Generates audit-ready policy content using OpenAI GPT-4o.
Replaces legacy Anthropic integration.
"""

import os
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import time
import openai
from app.config import settings

from app.services.policy_template_structure import PolicyTemplateStructure
from app.services.policy_intents import get_policy_intents, get_mapped_controls, POLICY_CONTROL_MAP


class PolicyGenerationService:
    """
    Service for generating ISO 27001:2022 and SOC 2 compliant policies using AI
    Uses OpenAI GPT-4o for superior reasoning and formatting.
    """
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize the service with OpenAI Only
        """
        self.openai_key = settings.OPENAI_API_KEY or os.getenv("OPENAI_API_KEY")
        self.openai_client = None
        self.provider = "none"

        if self.openai_key:
            try:
                self.openai_client = openai.OpenAI(api_key=self.openai_key)
                self.provider = "openai"
                print("DEBUG: initialized OpenAI GPT-4-Turbo client for Policy Generation.")
            except Exception as e:
                print(f"CRITICAL: Failed to init OpenAI: {e}")
                
        if self.provider == "none":
            print("CRITICAL WARNING: No Valid OpenAI Key found. Policy Generation will fail.")

        self.template_structure = PolicyTemplateStructure()
    
    def _build_system_prompt(self) -> str:
        return "You are a Senior GRC Auditor & Security Engineer. Your task is to write policies that are concise, enforce 'SHALL' statements, and avoid corporate fluff. Use professional auditor language."

    def _build_user_prompt(self, policy_name: str, company_name: str, cloud_stack: str) -> str:
        intents = get_policy_intents(policy_name)
        controls = get_mapped_controls(policy_name)
        
        if not intents:
            print(f"WARNING: No specific intents for '{policy_name}'. Using generic defaults.")
            intents = {
                "mandatory_elements": [
                    "Purpose and Scope",
                    "Roles and Responsibilities",
                    "Policy Statements",
                    "Enforcement",
                    "Review Cycle"
                ],
                "section_specific_requirements": {}
            }
            controls = ["ISO 27001 A.5.1 (Policies for Information Security)"]

        prompt = f"""
CONTEXT:
Organization: {company_name}
Cloud Stack: {cloud_stack}

TASK: Generate a comprehensive, audit-ready policy for "{policy_name}".

CRITICAL REQUIREMENTS - MUST BE FOLLOWED EXACTLY:

1. STRUCTURE: Use the 10-section format below with these EXACT headers:
   - 1. Purpose
   - 2. Scope
   - 3. Definitions
   - 4. Roles and Responsibilities
   - 5. Policy Statements
   - 6. Procedures and Implementation
   - 7. Exceptions and Deviations
   - 8. Compliance and Monitoring
   - 9. Enforcement and Violations
   - 10. Policy Review and Maintenance

2. MANDATORY COMPLIANCE ELEMENTS (YOU MUST INCLUDE ALL OF THESE):
"""
        # Add mandatory elements
        for i, element in enumerate(intents.get("mandatory_elements", []), 1):
            prompt += f"   {i}. {element}\n"
        
        prompt += f"\n3. MAPPED CONTROLS (You MUST explicitly reference these ISO/SOC2 controls):\n"
        for control in controls:
            prompt += f"   - {control}\n"
        
        # Add section-specific requirements
        if "section_specific_requirements" in intents:
            prompt += "\n4. SECTION-SPECIFIC REQUIREMENTS:\n"
            for section, requirements in intents["section_specific_requirements"].items():
                prompt += f"\n   {section.upper()}:\n"
                if isinstance(requirements, list):
                    for req in requirements:
                        prompt += f"   - {req}\n"
                else:
                    prompt += f"   - {requirements}\n"
        
        prompt += f"""

5. QUALITY STANDARDS:
   - Use "SHALL" or "MUST" for all mandatory requirements.
   - Be specific to the Cloud Stack ({cloud_stack}) where applicable (e.g. mention AWS IAM for Access Control).
   - Avoid passive voice. Use active, direct language.
   - Include specific evidence artifacts an auditor would ask for.

6. METADATA TABLE (Place this at the very top of the output):
| Document ID | POL-{policy_name.replace(' ', '-').upper()}-001 |
| :--- | :--- |
| **Version** | 1.0.0 |
| **Effective Date** | {datetime.now().strftime('%Y-%m-%d')} |
| **Owner** | Chief Information Security Officer (CISO) |
| **Classification** | Internal |
| **Generated By** | AI Auditor (GPT-4-Turbo) |

Output valid Markdown only. Do not wrap in ```markdown blocks.
"""
        return prompt

    def generate_policy(self, 
                       policy_name: str, 
                       company_name: str = "AssuRisk",
                       temperature: float = 0.1) -> Dict:
        """
        Generates a complete policy document using OpenAI GPT-4-Turbo.
        """
        # Soft-Match / Fallback for unknown policies
        if policy_name not in POLICY_CONTROL_MAP:
            print(f"WARNING: Policy '{policy_name}' not explicitly mapped. Using default controls.")
            
        # Hardcoded stack for now, ideally comes from settings
        cloud_stack = "AWS, Office 365, GitHub"
        
        system_prompt = self._build_system_prompt()
        user_prompt = self._build_user_prompt(policy_name, company_name, cloud_stack)
        
        generated_content = ""
        
        # 1. OpenAI Only
        if self.provider == "openai" and self.openai_client:
            print(f"  Generating {policy_name} with OpenAI GPT-4-Turbo...")
            try:
                response = self.openai_client.chat.completions.create(
                    model="gpt-4-turbo",
                    messages=[
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_prompt}
                    ],
                    max_tokens=4000,
                    temperature=temperature
                )
                generated_content = response.choices[0].message.content
            except Exception as e:
                print(f"  âš  OpenAI Failure: {str(e)}")
                return {"success": False, "error": f"OpenAI Generation Failed: {str(e)}"}

        # Final Check
        if not generated_content:
            return {"success": False, "error": "AI Generation Validation Failed."}

        
        # Validate
        validation_results = self._validate_generated_policy(policy_name, generated_content)
        
        # Coverage
        from app.services.policy_intents import validate_policy_coverage
        coverage = validate_policy_coverage(policy_name, generated_content)
        
        return {
            "success": True,
            "policy_name": policy_name,
            "content": generated_content,
            "metadata": {
                "document_id": f"POL-{policy_name.replace(' ', '-').upper()}-001",
                "version": "1.0.0",
                "effective_date": datetime.now().strftime('%Y-%m-%d'),
                "next_review_date": (datetime.now() + timedelta(days=365)).strftime('%Y-%m-%d'),
                "owner": "Chief Information Security Officer (CISO)",
                "classification": "Internal",
                "mapped_controls": get_mapped_controls(policy_name),
                "word_count": len(generated_content.split()),
                "generated_at": datetime.now().isoformat(),
                "provider": self.provider
            },
            "validation": validation_results,
            "intent_coverage": coverage
        }

    def _validate_generated_policy(self, policy_name: str, content: str) -> Dict:
        """
        Validates generated policy against structure and quality requirements
        """
        errors = []
        warnings = []
        
        # Check for all 10 required sections
        required_sections = [
            "1. Purpose", "2. Scope", "3. Definitions", "4. Roles and Responsibilities",
            "5. Policy Statements", "6. Procedures and Implementation", "7. Exceptions and Deviations",
            "8. Compliance and Monitoring", "9. Enforcement and Violations", "10. Policy Review and Maintenance"
        ]
        
        for section in required_sections:
            if section not in content:
                errors.append(f"Missing required section: {section}")
        
        word_count = len(content.split())
        if word_count < 1000:
            warnings.append(f"Policy is short ({word_count} words).")
            
        return {"valid": len(errors) == 0, "errors": errors, "warnings": warnings}


# Convenience function
def generate_policy_quick(policy_name: str, 
                         api_key: Optional[str] = None,
                         company_name: str = "AssuRisk") -> Dict:
    service = PolicyGenerationService(api_key)
    return service.generate_policy(policy_name, company_name)
    
if __name__ == "__main__":
    print("Testing Policy Generation...")
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("No OpenAI Key in env.")
    
    svc = PolicyGenerationService()
    print(f"Provider: {svc.provider}")
    # res = svc.generate_policy("Access Control Policy")
    # print(res.get("content")[:500])
